import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const myApi = createApi({
  reducerPath: "myApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "http://localhost:3000/",
  }),
  tagTypes: ["Posts"], // Defines the possible tags that can be used in your RTK Query API.
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], string>({
      query: () => "posts",
      providesTags: ["Posts"], // getPosts is tagged as "Posts". Now, RTK Query knows that this cache belongs to the "Posts" tag.
    }),
    addPost: builder.mutation<Post, Post>({
      query: (post) => ({
        url: "posts",
        method: "POST",
        body: post,
      }),
      invalidatesTags: ["Posts"], // This tells RTK Query that "Posts" data is outdated and therefore it automatically refetches getPosts to update the UI.
    }),
  }),
});

export const { useGetPostsQuery, useAddPostMutation } = myApi;

// useGetPostsQuery, useAddPostMutation, etc are automatically generated by React because here we are using RTK with react
// For GET request we use builder.query
// For POST, PUT, PATCH, DELETE request we use builder.mutation


// TAGS
// Tags help manage caching and automatic refetching of data. 
// Tags allow you to invalidate or update cached data when mutations (like adding or deleting posts) occur.
// useGetPostsQuery fetches data once and caches it. 
// Now, when useAddPostMutation is called it adds the new post to the backend, but it is not aware of the change. 
// The cached data is still the old one. To invalidate this cached data and inform RTK to refetch the latest data, we make use of tags.
// This is how this happens:
// The getPosts query is associated with the "Posts" tag`. [thanks to "providesTags" field]
// When addPost is called, it invalidates "Posts". [thanks to "invalidatesTags" field]
// RTK Query sees "Posts" is outdated and refetches getPosts automatically. [Now, there is no need to manually call refetch()]

// CACHE
// Cache is a storage mechanism that temporarily holds copies of data for quick retrieval without making a new request to the server.
// Benefits of Caching (data once fetched is cached) in RTK Query:
// 1. If another component requests the same data, it is instantly returned without making another API request.
// 2. If such components (components that are making these requests) re-render, data is instantly returned without making another API request.
// 3. If a user revisits a page where such a request is made, data is instantly returned without making another API request.
// 4. Automatically updates the cache when mutations happen (invalidatesTags).
// Overall application level benefits are:
// 1. No data flickers, as cached data is returned instantly (unless invalidated)
// 2. No unnecessary API calls (like same request from another component or during re-render of such components even when no data has changed)
// 3. Reduces server load, as number of API calls are reduced
// 4. Ensures that UI updates are always with the latest data (thanks to invalidateTags)